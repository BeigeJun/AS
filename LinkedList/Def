#define _CRT_SECURE_NO_WARNINGS
#ifndef DEF_H
#define DEF_H
#include<stdio.h>
#include <stdlib.h>
#include<Windows.h>
#include"Node.h"
#include"LinkedList.h"
LinkedList* Create()
{
	LinkedList* _ptList = (LinkedList*)calloc(1, sizeof(LinkedList));
	_ptList->m_pHead = _ptList->m_pTail;
	_ptList->m_pTail = _ptList->m_pHead;
	_ptList->m_pCurrent = NULL;
	_ptList->m_uCount = 0;
	return _ptList;
}
void Destroy(LinkedList* _ptList)
{
	free(_ptList);
}
Node* GetNode(int _Object)
{
	Node* pNode = (Node*)malloc(sizeof(Node));
	pNode->m_pNext = pNode;
	pNode->m_Previous = pNode;
	pNode->m_iObject = _Object;
	return pNode;
}
Node* Read(LinkedList* _ptList, unsigned int num)
{
	Node* view = _ptList->m_pHead;
	for (int i = 1; i < num; i++)
	{
		view = view->m_pNext;
	}
	printf("%d 번째 노드의 값은 %d", num, view->m_iObject);
	return 0;
}
void Traversal(LinkedList* _ptList)
{

	Node* view = _ptList->m_pHead;


	for (int i = 0; i != _ptList->m_uCount; i++) {
		printf("%d  ", view->m_iObject);
		view = view->m_pNext;
	}
	printf("\n");
}
Node* AppendFromHead(LinkedList* _ptList, int _iObject)
{
	_ptList->m_pCurrent = GetNode(_iObject);

	if (_ptList->m_pHead) {
		_ptList->m_pCurrent->m_pNext = _ptList->m_pHead;
		_ptList->m_pHead->m_Previous = _ptList->m_pCurrent;
	}
	else
		_ptList->m_pTail = _ptList->m_pCurrent;

	_ptList->m_pHead = _ptList->m_pCurrent;
	(_ptList->m_uCount)++;
	_ptList->m_pCurrent = NULL;
	printf("맨 앞에 %d 추가\n", _iObject);
	return 0;
}
Node* AppendFromTail(LinkedList* _ptList, int _iObject)
{
	Node* New = GetNode(_iObject);
	Node* pointer = _ptList->m_pTail;
	if (_ptList->m_uCount==0) {
		_ptList->m_pHead = New;
		_ptList->m_pTail = New;
		(_ptList->m_uCount)++;
	}
	else {
		pointer->m_pNext = New;
		New->m_Previous = pointer;
		_ptList->m_pTail = New;
		(_ptList->m_uCount)++;
	}
	printf("맨 뒤에 %d 추가\n", _iObject);
	return 0;
}
Node* DeleteFromHead(LinkedList* _ptList)
{
	if (_ptList->m_uCount < 1)
	{
		printf("노드의 개수가 0개입니다.\n");
		return 0;
	}
	Node* pointer;
	pointer = _ptList->m_pHead;            // pointer가 리스트의 맨 앞 노드를 가르킨다
	pointer = pointer->m_pNext;            // 그 다음 노드로 이동한다
	pointer->m_Previous = pointer;         // 노드의 Pv값을 자신으로 지정하여 앞 노드와 끊어준다

	pointer = _ptList->m_pHead;            //pointer가 리스트의 맨앞 노드를 가르킨다.
	_ptList->m_pHead = pointer->m_pNext;   //맨 앞 노드를 가르키는 값을 다음 노드로 변경해준다
	(_ptList->m_uCount)--;                 //노드의 갯수를 1개 줄여준다
	free(pointer);                         //pointer는 맨앞 노드를 가르키고 있었으니 노드를 삭제해줌으로써 맨앞 노드가 사라진다.
	return 0;
}
Node* DeleteFromTail(LinkedList* _ptList)
{
	if (_ptList->m_uCount < 1)
	{
		printf("노드의 개수가 0개입니다.\n");
		return 0;
	}
	Node* pointer;
	pointer = _ptList->m_pTail;
	pointer = pointer->m_Previous;
	pointer->m_pNext = pointer;

	pointer = _ptList->m_pTail;
	_ptList->m_pTail = pointer->m_Previous;
	free(pointer);
	(_ptList->m_uCount)--;
	return 0;
}
void DeleteAll(LinkedList* _ptList)
{
	Node* First;
	First = _ptList->m_pHead;
	for (int i = _ptList->m_uCount; i > 0; i--)
	{
		First = First->m_pNext;
		free(First->m_Previous);
	}
	free(First);
	_ptList->m_pHead = _ptList->m_pTail;
	_ptList->m_pTail = _ptList->m_pHead;
	_ptList->m_uCount = 0;
}
Node* InsertBefor(LinkedList* _ptList, int num, int a)
{
	if (_ptList->m_uCount < 1)
	{
		printf("노드의 개수가 0개입니다.\n");
		return 0;
	}
	Node* pointer=_ptList->m_pHead;
	Node* pointer_before;
	Node* New = GetNode(a);
	if (num == 1)
	{
		AppendFromHead(_ptList, a);
	}
	else {
		for (int i = 0; i != num - 1; i++)
		{
			pointer = pointer->m_pNext;
		}
		pointer_before = pointer->m_Previous;
		New->m_pNext = pointer;
		pointer->m_Previous = New;
		New->m_Previous = pointer_before;
		pointer_before->m_pNext = New;
		(_ptList->m_uCount)++;
	}
	return 0;
}
Node* InsertAfter(LinkedList* _ptList, int num, int a)  //기존노드 뒷 삽입
{
	if (_ptList->m_uCount < 1)
	{
		printf("노드의 개수가 0개입니다.\n");
		return 0;
	}
	Node* pointer = _ptList->m_pHead;
	Node* pointer_next;
	Node* New = GetNode(a);
	if (num == _ptList->m_uCount)
	{
		AppendFromTail(_ptList, a);
	}
	else {
		for (int i = 0; i != num - 1; i++)
		{
			pointer = pointer->m_pNext;
		}
		pointer_next = pointer->m_pNext;
		New->m_pNext = pointer_next;
		pointer->m_pNext = New;
		New->m_Previous = pointer_next;
		pointer_next->m_Previous = New;
		(_ptList->m_uCount)++;
	}
	return 0;
}
Node* Delete(LinkedList* _ptList, int a)
{
	Node* SomeThing;
	Node* SomeThingBefore;
	Node* SomeThingNext;
	if (_ptList->m_uCount == 0)
	{
		printf("노드의 갯수가 0개 이하입니다.\n");
	}
	else if (_ptList->m_uCount < a)
	{
		printf("%d번째 노드는 없습니다.\n", a);
	}
	else {
		if (_ptList->m_uCount == a) {
			DeleteFromTail(_ptList);
		}
		else if (a == 1) {
			DeleteFromHead(_ptList);
		}
		else if (a <= 2147483647 && a >= 0)
		{
			SomeThing = _ptList->m_pHead;
			for(int i = 0; i <= a-2; i++)
			{
				SomeThing = SomeThing->m_pNext;
			}
			SomeThingBefore = SomeThing->m_Previous;
			SomeThingNext = SomeThing->m_pNext;


			SomeThingBefore->m_pNext = SomeThing->m_pNext;
			SomeThingNext->m_Previous = SomeThing->m_Previous;

			free(SomeThing);
			(_ptList->m_uCount)--;
		}
		else
			printf("2147483647이하의 양의 정수를 입력해주십시오\n");
	}
	return 0;
}
Node* Modify(LinkedList* _ptList, int a, int b)
{
	Node* SomeThing;
	if (_ptList->m_uCount == 0)
	{
		printf("노드의 갯수가 0개 이하입니다.\n");
	}
	else if (_ptList->m_uCount < a)
	{
		printf("%d번째 노드는 없습니다.\n", a);
	}
	else {
		SomeThing = _ptList->m_pHead;
		for (int i = 0; i <= a - 2; i++)
		{
			SomeThing = SomeThing->m_pNext;
		}
		SomeThing->m_iObject = b;
	}
	return 0;
}
Node* LinearSearchByUnique(LinkedList* _ptList, int x) 
{
	int ox = 0;
	int i = 0;
	Node* pointer = _ptList->m_pHead;
	for (i = 0; i != _ptList->m_uCount; i++)
	{
		if (pointer->m_iObject == x)
		{
			printf("%d번째에 있습니다.\n", i+1);
			break;
			ox++;
		}
		pointer = pointer->m_pNext;
		if (i == _ptList->m_uCount-1) {
			if (ox != 0)
			{
				continue;
			}
			else if(ox==0){
				printf("없는 숫자 입니다.\n");
			}
		}
	}
	return 0;
}
void LinearSearchByDuplicate(LinkedList* _ptList, int x)
{
	
	int ox = 0;
	int i = 0;
	Node* pointer = _ptList->m_pHead;
	for (i = 0; i != _ptList->m_uCount; i++)
	{
		if (pointer->m_iObject == x)
		{
			printf("%d번째 ", i + 1);
			ox++;
		}
		pointer = pointer->m_pNext;
		if (i == _ptList->m_uCount - 1) {
			if (ox != 0)
			{
				printf("에 있습니다.\n");
			}
			else if (ox == 0) {
				printf("없는 숫자 입니다.\n");
			}
		}
	}
}
Node* BinarySearchByUnique(LinkedList* _ptList, int target) {

	Node* pointer = _ptList->m_pHead;
	Node* head_pointer = _ptList->m_pHead;
	int half = 0;
	int count = _ptList->m_uCount;
	int where=1;
	int head_where = 1;
	for (int a = 0; a < _ptList->m_uCount+1; a++)
	{
		if (_ptList->m_uCount % 2 == 1) {
			half = count / 2 + 1;
			count = count / 2 + 1;
		}
		else {
			half = count / 2;
			count = count / 2;
		}

		for (int i = 0; i < half-1; i++)
		{
			pointer = pointer->m_pNext;
			where = where + 1;
		}

		int what = pointer->m_iObject;
		if (what == target)
		{
			printf("%d번째", where);
			break;
		}
		else if (what < target)
		{ 
			pointer = pointer->m_pNext;
			head_pointer = pointer;
			where = where + 1;
			head_where = where;
			what = pointer->m_iObject;
			if (what == target)
			{
				printf("%d번째", where);
				break;
			}
		}
		else if(what > target)
		{
			pointer = head_pointer;
			where = head_where;
			what = pointer->m_iObject;
			if (what == target)
			{
				printf("%d번째", where);
				break;
			}
		}
		else {
			printf("?\n");
		}
	}
	return 0;
}
void BinarySearchByDuplicate(LinkedList* _ptList, int target, int start, int end)
{

	Node* pointer = _ptList->m_pHead;
	Node* head_pointer = _ptList->m_pHead;
	int half = (start + end) / 2;
	int where = 1;
	int head_where = 1;
	for (int a = 0; a < half; a++)
	{
		half = (start + end) / 2;
	
		for (int i = 0; i < half - 1; i++)
		{
			pointer = pointer->m_pNext;
			where = where + 1;
		}

		int what = pointer->m_iObject;
		if (what == target)
		{
			printf("%d번째", where);
			BinarySearchByDuplicate(_ptList,target,start,half-1);
			BinarySearchByDuplicate(_ptList,target,half+1,end);
			break;
		}
		else if (what < target)
		{
			pointer = pointer->m_pNext;
			head_pointer = pointer;
			where = where + 1;
			head_where = where;
			what = pointer->m_iObject;
			if (what == target)
			{
				printf("%d번째", where);
				BinarySearchByDuplicate(_ptList, target, start, half - 1);
				break;
			}

		}
		else if (what > target)
		{
			pointer = head_pointer;
			where = head_where;
			what = pointer->m_iObject;
			if (what == target)

			{
				printf("%d번째", where);
				BinarySearchByDuplicate(_ptList, target, half + 1, end);
				break;
			}

		}
		else {
			printf("?\n");
			break;
		}
	}
}
void SortByBubble(LinkedList* _ptList)
{
	for (int i = 0; i != _ptList->m_uCount; i++)
	{
		Node* pointer = _ptList->m_pHead;
		Node* pointerNext = pointer->m_pNext;
		for (int j = 0; j != _ptList->m_uCount; j++)
		{
			if (pointer->m_iObject > pointerNext->m_iObject)
			{
				int temp = 0;
				temp = pointerNext->m_iObject;
				pointerNext->m_iObject = pointer->m_iObject;
				pointer->m_iObject = temp;
				pointer = pointer->m_pNext;
				pointerNext = pointerNext->m_pNext;
				continue;
			}
			pointer = pointer->m_pNext;
			pointerNext = pointerNext->m_pNext;
		}
	}
}
void SortByInsertion(LinkedList* _ptList)
{
	Node* pointer = _ptList->m_pHead;
	for (int i = 1; i < _ptList->m_uCount; i++)
	{
		Node* Next_pointer = pointer->m_pNext;
		for (int k = 1; k < _ptList->m_uCount; k++)
		{
			if (pointer->m_iObject > Next_pointer->m_iObject)
			{
				int temp;
				temp = pointer->m_iObject;
				pointer->m_iObject = Next_pointer->m_iObject;
				Next_pointer->m_iObject = temp;
			}
			Next_pointer = Next_pointer->m_pNext;
		}
		pointer = pointer->m_pNext;
	}
}
void SortBySelection(LinkedList* _ptList)
{

	for (int z = 0; z < _ptList->m_uCount; z++)
	{
		Node* pointer = _ptList->m_pHead;
		Node* head = _ptList->m_pHead;
		int Min;
		
		for (int x = 0; x < z; x++)
		{
			pointer = pointer->m_pNext;
		}
		Min = pointer->m_iObject;

		for (int i = z; i < _ptList->m_uCount; i++)
		{
			if (pointer->m_iObject < Min)
			{
				Min = pointer->m_iObject;
			}
			pointer = pointer->m_pNext;
		}

		pointer = _ptList->m_pHead;
		for (int x = 0; x < z; x++)
		{
			pointer = pointer->m_pNext;
		}

		for (int x = 0; x < _ptList->m_uCount; x++)
		{
			if (pointer->m_iObject != Min)
			{
				pointer = pointer->m_pNext;
			}
		}

		for (int x = 0; x < z; x++)
		{
			head = head->m_pNext;
		}
		int temp = 0;
		temp = head->m_iObject;
		head->m_iObject = pointer->m_iObject;
		pointer->m_iObject = temp;
	}
}
int menu()
{
	char a;
	int number = 0;
	printf("관리자를 만드시겠습니까? x입력시 종료(o/x) : ");
	scanf_s("%c", &a);
	system("cls");
	if (a == 'x')
	{
		printf("종료합니다.");
		return 0;
	}
	else if (a == 'o')
	{
		printf("관리자 master가 생성되었습니다.\n");
	}
	else
	{
		printf("잘못입력하셨습니다. 프로그램을 종료합니다.");
		return 0;
	}
	system("cls");
	LinkedList* master = Create();
	while (1)
	{
		printf(" ------------기능을 선택해 주십쇼--------------\n");
		printf("|1.맨 앞에 노드 추가                           |\n");
		printf("|2.맨 뒤에 노드 추가                           |\n");
		printf("|3.리스트의 노드들 순회                        |\n");
		printf("|4.관리자 지우기(끝내기)                       |\n");
		printf("|5.맨 앞 노드 지우기                           |\n");
		printf("|6.맨 뒤 노드 지우기                           |\n");
		printf("|7.모든 노드 지우기                            |\n");
		printf("|8.지정 노드 지우기                            |\n");
		printf("|9.임의 노드 수정                              |\n");
		printf("|10.단일 선형 탐색                             |\n");
		printf("|11.버블정렬                                   |\n");
		printf("|12.삽입정렬                                   |\n");
		printf("|13.선택정렬                                   |\n");
		printf("|14.단일 이진 탐색                             |\n");
		printf("|15.다중 선형 탐색                             |\n");
		printf("|16.기존 노드 앞 삽입                          |\n");
		printf("|17.기존 노드 뒤 삽입                          |\n");
		printf("|18.다중 이진 탐색                             |\n");
		printf(" ----------------------------------------------\n");
		printf("입력 : ");
		scanf_s("%d", &number);
		rewind(stdin);
		if (number == '\0')
		{
			printf("잘못된 입력입니다.\n");
			continue;
		}
		if (number > 2147483647 && number < 0)
		{
			printf("2147483647이하의 양의 정수를 입력해주십시오\n");
			continue;
		}

		system("cls");

		if (number == 1) {
			unsigned int append_num = 0;
			printf("추가할 노드의 고유 숫자를 입력하시오: ");
			scanf_s("%d", &append_num);
			rewind(stdin);
			if (append_num == '\0')
			{
				printf("잘못된 입력입니다.\n");
				continue;
			}
			if (append_num <= 2147483647 && append_num >= 0)
			{
				AppendFromHead(master, append_num);
				Traversal(master);
				continue;
			}
			printf("2147483647이하의 양의 정수를 입력해주십시오\n");
			continue;
		}
		else if (number == 2) {
			unsigned int append_num = 0;
			printf("추가할 노드의 고유 숫자를 입력하시오: ");
			scanf_s("%d", &append_num);
			rewind(stdin);
			if (append_num == '\0')
			{
				printf("잘못된 입력입니다.\n");
				continue;
			}
			if (append_num <= 2147483647 && append_num >= 0)
			{
				AppendFromTail(master, append_num);
				Traversal(master);
				continue;
			}
			printf("2147483647이하의 양의 정수를 입력해주십시오\n");
		}
		else if (number == 3) {
			Traversal(master);
		}
		else if (number == 4) {
			Destroy(master);
			printf("종료합니다.");
			return 0;
		}
		else if (number == 5) {
			DeleteFromHead(master);
		}
		else if (number == 6) {
			DeleteFromTail(master);
		}
		else if (number == 7) {
			if (master->m_uCount == 0)
			{
				printf("노드의 개수가 0개입니다.");
				continue;
			}
			DeleteAll(master);
		}
		else if (number == 8) {
			unsigned int append_num = 0;
			printf("몇번째 노드를 삭제하겠습니까? : ");
			scanf_s("%d", &append_num);
			rewind(stdin);
			if (append_num == '\0')
			{
				printf("잘못된 입력입니다.\n");
				continue;
			}
			if (append_num <= 2147483647 && append_num >= 0)
			{
				Delete(master, append_num);
				continue;
			}
			printf("2147483647이하의 양의 정수를 입력해주십시오\n");
		}
		else if (number == 9) {
			unsigned int aNum;
			unsigned int bNum;
			printf("몇번째 노드를 변경하시겠습니까? : ");
			scanf_s("%d", &aNum);
			rewind(stdin);
			if (aNum == '\0')
			{
				printf("잘못된 입력입니다.\n");
				continue;
			}
			if (aNum > 2147483647 && aNum < 0)
			{
				printf("2147483647이하의 양의 정수를 입력해주십시오\n");
				continue;
			}
			printf("노드의 고유 번호를 무엇으로 바꾸시겠습니까? : ");
			scanf_s("%d", &bNum);
			rewind(stdin);
			if (bNum == '\0')
			{
				printf("잘못된 입력입니다.\n");
				continue;
			}
			if (bNum > 2147483647 && bNum < 0)
			{
				printf("2147483647이하의 양의 정수를 입력해주십시오\n");
				continue;
			}
			Modify(master, aNum, bNum);
		}
		else if (number == 10) {
			unsigned int Num;
			printf("찾을 고유 숫자를 입력하십시오 : ");
			scanf_s("%d", &Num);
			rewind(stdin);
			if (Num == '\0')
			{
				printf("잘못된 입력입니다.\n");
				continue;
			}
			if (Num > 2147483647 && Num < 0)
			{
				printf("2147483647이하의 양의 정수를 입력해주십시오\n");
				continue;
			}
			LinearSearchByUnique(master, Num);
		}
		else if (number == 11)
		{
			SortByBubble(master);
		}
		else if (number == 12)
		{
			SortByInsertion(master);
		}
		else if (number == 13)
		{
			SortBySelection(master);
		}
		else if (number == 14)
		{
			int target;
			printf("찾을 고유 숫자를 입력하십시오 : ");
			scanf_s("%d", &target);
			rewind(stdin);
			if (target == '\0')
			{
				printf("잘못된 입력입니다.\n");
				continue;
			}
			if (target > 2147483647 && target < 0)
			{
				printf("2147483647이하의 양의 정수를 입력해주십시오\n");
				continue;
			}
			BinarySearchByUnique(master, target);
		}
		else if (number == 15)
		{
			int target;
			printf("찾을 고유 숫자를 입력하십시오 : ");
			scanf_s("%d", &target);
			rewind(stdin);
			if (target == '\0')
			{
				printf("잘못된 입력입니다.\n");
				continue;
			}
			if (target > 2147483647 && target < 0)
			{
				printf("2147483647이하의 양의 정수를 입력해주십시오\n");
				continue;
			}
			LinearSearchByDuplicate(master, target);
		}
		else if (number == 16) {
			int where, num;
			printf("추가할 위치를 입력하십시오 : ");
			scanf_s("%d", &where);
			rewind(stdin);
			if (where == '\0')
			{
				printf("잘못된 입력입니다.\n");
				continue;
			}
			if (where > 2147483647 && where < 0)
			{
				printf("2147483647이하의 양의 정수를 입력해주십시오\n");
				continue;
			}
			printf("추가할 숫자를 입력하십시오 : ");
			scanf_s("%d", &num);
			rewind(stdin);
			if (num == '\0')
			{
				printf("잘못된 입력입니다.\n");
				continue;
			}
			if (num > 2147483647 && num < 0)
			{
				printf("2147483647이하의 양의 정수를 입력해주십시오\n");
				continue;
			}
			InsertBefor(master, where, num);
		}
		else if (number == 17) {
			int where, num;
			printf("추가할 위치를 입력하십시오 : ");
			scanf_s("%d", &where);
			rewind(stdin);
			if (where == '\0')
			{
				printf("잘못된 입력입니다.\n");
				continue;
			}
			if (where > 2147483647 && where < 0)
			{
				printf("2147483647이하의 양의 정수를 입력해주십시오\n");
				continue;
			}
			printf("추가할 숫자를 입력하십시오 : ");
			scanf_s("%d", &num);
			rewind(stdin);
			if (num == '\0')
			{
				printf("잘못된 입력입니다.\n");
				continue;
			}
			if (num > 2147483647 && num < 0)
			{
				printf("2147483647이하의 양의 정수를 입력해주십시오\n");
				continue;
			}
			InsertAfter(master, where, num);
		}
		else if (number == 18) {
			{
				int target, start, end;
				start = 1;
				end = master->m_uCount;
				printf("찾을 고유 숫자를 입력하십시오 : ");
				scanf_s("%d", &target);
				rewind(stdin);
				if (target == '\0')
				{
					printf("잘못된 입력입니다.\n");
					continue;
				}
				if (target > 2147483647 && target < 0)
				{
					printf("2147483647이하의 양의 정수를 입력해주십시오\n");
					continue;
				}
				BinarySearchByDuplicate(master, target, start, end);
			}
		}
		else {
			printf("잘못된 접근입니다.\n");
		}
		Traversal(master);
	}
}
#endif
